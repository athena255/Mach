package main

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
)

// defmap["MH"][0x4] = ["MH_blah", "MH_otherblah"]
// mapping prefix to a value : string[] map because of situations like this:
// #define MH_foo_bar 0x00
// #define MH_foo_xbar 0
var (
	definesRegexp   *regexp.Regexp = regexp.MustCompile(`^#define\s+((\S+?)_\S+)\s+([^/\n\"]*)`)
	definesOrRegexp *regexp.Regexp = regexp.MustCompile(`\((\S+)\s*\|\s*\S+\)`) // for matching (0x1c | LC_REQ_DYLD)
	defMap                         = map[string]map[uint64][]string{}
	tab                            = "    "
)

func usage() {
	fmt.Println("This script turns defines into switch statements")
	fmt.Println("Usage ./mach [myfile]")
	os.Exit(1)
}

func printFile() {
	endString := fmt.Sprintf("%sdefault:\n%s%sreturn \"UNKNOWN\";\n%s}\n}\n", tab, tab, tab, tab)
	fmt.Println("// This file is auto-generated by mach.go")
	fmt.Println("#pragma once")
	fmt.Println("#include <string>")

	for prefix, valMap := range defMap { // string -> map[uint64][]string
		fmt.Printf("\nstd::string toString%s(uint64_t s){\n%sswitch(s){\n", prefix, tab)
		for _, defs := range valMap { // 0x4 --> ["MH_blah", "MH_blah1"]
			fmt.Printf("%scase %s", tab, defs[0])
			// for now, only bind the first one
			fmt.Printf(":\n")
			fmt.Println(tab, tab, `return "`, defs[0], `";`)
		}
		fmt.Printf(endString)
	}
	fmt.Println("// found ", len(defMap))
}

func main() {
	if len(os.Args) != 2 {
		usage()
	}

	file, err := os.Open(os.Args[1])

	if err != nil {
		os.Exit(1)
	}

	defer file.Close()
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		res := definesRegexp.FindStringSubmatch(scanner.Text())

		if res != nil && len(res) == 4 {
			res[3] = strings.TrimSpace(res[3]) // #define blah 0x3
			val, err := strconv.ParseUint(res[3], 0, 64)

			if err != nil { // skip #define blah "some string"
				// match #define blah (0x18 | LC_REQ_DYLD)
				altdef := definesOrRegexp.FindStringSubmatch(res[3])
				if altdef != nil && len(altdef) == 2 {
					val2, err := strconv.ParseUint(altdef[1], 0, 64)
					if err == nil {
						addToMap(res[2], (val2 + 0x80000000), res[1])
					}
				}
			} else {
				addToMap(res[2], val, res[1])
			}

		}
	}
	printFile()
}

func addToMap(prefix string, val uint64, def string) {
	if defMap[prefix] == nil {
		defMap[prefix] = map[uint64][]string{}
	}
	defMap[prefix][val] = append(defMap[prefix][val], def)
}
